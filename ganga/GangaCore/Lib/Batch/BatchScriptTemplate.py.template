#!/usr/bin/env python
from __future__ import print_function
import shutil
import os
import time
import popen2
import glob
import mimetypes

############################################################################################

###INLINEMODULES###
###INLINEHOSTNAMEFUNCTION###

############################################################################################

input_sandbox = ###INPUT_SANDBOX###
sharedoutputpath = ###SHAREDOUTPUTPATH###
outputpatterns = ###OUTPUTPATTERNS###
appscriptpath = ###APPSCRIPTPATH###
environment = ###ENVIRONMENT###

# jobid is a string
jobid = ###JOBID###

###PREEXECUTE###

def flush_file(f):
    f.flush()
    os.fsync(f.fileno()) #this forces a global flush (cache synchronization on AFS)

def open_file(fname):
    try:
        filehandle=open(fname,'w')
    except IOError as x:
        print('ERROR: not able to write a status file: ', fname)
        print('ERROR: ',x)
        raise
    return filehandle

def multi_glob(pats, exclude=None):
    """ glob using a list of patterns and removing duplicate files, exclude name in the list for which the callback exclude(name) return true
    example: advanced_glob(['*.jpg','*.gif'],exclude=lambda n:len(n)>20) return a list of all JPG and GIF files which have names shorter then 20 characters
    """

    unique = {}
    if exclude is None:
        def exclude(n): return 0

    for p in pats:
        for f in glob.glob(p):
            unique[f] = 1

    return [name for name in unique.keys() if not exclude(name)]


def recursive_copy(src, dest):
    """ copy src file (or a directory tree if src specifies a directory) to dest directory. dest must be a directory and must exist.
    if src is a relative path, then the src directory structure is preserved in dest.
    """
    
    if not os.path.isdir(dest):
        raise ValueError(
            'resursive_copy: destination %s must specify a directory (which exists)' % dest)

    if os.path.isdir(src):
        destdir = dest
        srcdir, srcbase = os.path.split(src.rstrip('/'))
        if not srcdir == '' and not os.path.isabs(src):
            destdir = os.path.join(destdir, srcdir)
            if not os.path.isdir(destdir):
                os.makedirs(destdir)
        shutil.copytree(src, os.path.join(destdir, srcbase))
    else:

        srcdir = os.path.dirname(src.rstrip('/'))
        if srcdir == '' or os.path.isabs(src):
            shutil.copy(src, dest)
        else:
            destdir = os.path.join(dest, srcdir)
            if not os.path.isdir(destdir):
                os.makedirs(destdir)
            shutil.copy(src, destdir)


statusfilename = os.path.join(sharedoutputpath,'__jobstatus__')
heartbeatfilename = os.path.join(sharedoutputpath,'__heartbeat__')

statusfile=open_file(statusfilename)
heartbeatfile=open_file(heartbeatfilename)

line='START: '+ time.strftime('%a %b %d %H:%M:%S %Y',time.gmtime(time.time())) + os.linesep
try:
    line+='PID: ' + os.getenv('###JOBIDNAME###') + os.linesep
    line+='QUEUE: ' + os.getenv('###QUEUENAME###') + os.linesep
    line+='ACTUALCE: ' + hostname() + os.linesep
except:
    pass
statusfile.writelines(line)
flush_file(statusfile)

import tarfile

# -- WARNING: get the input files including the python modules BEFORE sys.path.insert()
# -- SINCE PYTHON 2.6 THERE WAS A SUBTLE CHANGE OF SEMANTICS IN THIS AREA

for f in input_sandbox:
    if mimetypes.guess_type(f)[1] in ['gzip', 'bzip2']:
        getPackedInputSandbox(f)
    else:
        shutil.copy(f, os.path.join(os.getcwd(), os.path.basename(f)))

# -- END OF MOVED CODE BLOCK

#get input files
###DOWNLOADINPUTFILES###

# create inputdata list
###CREATEINPUTDATALIST###

import sys
sys.path.insert(0, ###GANGADIR###)
sys.path.insert(0,os.path.join(os.getcwd(),PYTHON_DIR))

import subprocess

fullenvironment = os.environ.copy()
for key,value in environment.iteritems():
    fullenvironment[key] = value

sysout2 = os.dup(sys.stdout.fileno())
syserr2 = os.dup(sys.stderr.fileno())

print("--- GANGA APPLICATION OUTPUT BEGIN ---", file=sys.stdout)
print("--- GANGA APPLICATION ERROR BEGIN ---", file=sys.stderr)
flush_file(sys.stdout)
flush_file(sys.stderr)

sys.stdout=open('./__syslog__','w')
sys.stderr=sys.stdout

result = 255



try:
    child = subprocess.Popen(appscriptpath, shell=False, stdout=sysout2, stderr=syserr2, env=fullenvironment)

    while 1:
        result = child.poll()
        if result is not None:
            break
        heartbeatfile.write('.')
        flush_file(heartbeatfile)
        time.sleep(###HEARTBEATFREQUENCE###)
except Exception as x:
    print('ERROR: %s'%str(x))

flush_file(sys.stdout)
flush_file(sys.stderr)
sys.stdout=sys.__stdout__
sys.stderr=sys.__stderr__
print("--- GANGA APPLICATION OUTPUT END ---", file=sys.stdout)


try:
    filefilter
except:
    filefilter = None

createOutputSandbox(outputpatterns,filefilter,sharedoutputpath)

def printError(message):
    print(message, file=sys.stderr)

def printInfo(message):
    print(message, file=sys.stdout)

###OUTPUTUPLOADSPOSTPROCESSING###

print("--- GANGA APPLICATION ERROR END ---", file=sys.stderr)

###OUTPUTSANDBOXPOSTPROCESSING###

###POSTEXECUTE###

line='EXITCODE: ' + repr(result) + os.linesep
line+='STOP: '+time.strftime('%a %b %d %H:%M:%S %Y',time.gmtime(time.time())) + os.linesep
statusfile.writelines(line)

statusfile.close()
heartbeatfile.close()
os.unlink(heartbeatfilename)

sys.exit(result)


